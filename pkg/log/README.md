# Log

Пакет log отвечает за использование логера.

Публичный интерфейс построен на основе [log/slog](https://pkg.go.dev/log/slog).  
Внутренний [slog.Handler](https://pkg.go.dev/log/slog#Handler) использует библиотеку логирования [zerolog](https://pkg.go.dev/github.com/rs/zerolog).

 Возможности:
 - Несколько мест записи
    - [os.Stdout] (https://pkg.go.dev/os#pkg-variables)
    - Файл
 - Отдельный формат для каждого вывода
 - Перехват событий (например, для вставки данных телеметрии)

## Использование

 В самой простой конфигурации получаем вывод в `os.stdout`:
```go
logger, err := log.New(log.LoggerConfig{})
```

Возвращает `logger` - это указатель на [slog.logger] (https://pkg.go.dev/log/slog#handler).

`LoggerConfig` содержит настраиваемые параметры, которые также настраиваются в файлах YAML и JSON.

В дополнение к конфигурации, `New` принимают следующие опции:
 - `WithEventHook` - функции для перехвата событий логера

### Группы логеров

Для структурированного логирования можно создать иерархию логера, дочерние логеры наследуются от родителей:
```go
child := logger.WithGroup("child")
...
grandchild := child.WithGroup("grandchild")
```

Дети наследуют уровень логирования и все атрибуты родителей.

### Фильтры событий

Уровень логирования по умолчанию может быть установлен через `loggerConfig.level`.
Доступными уровнями являются `debug`,` info`, `error` и `disabled`.

Если уровень не установлен, используется `info`.

В дополнение вы можете установить уровень для группы, используя `LoggerConfig.Filters`.
Если группа или ее родитель есть в фильтре, то этой группе будет установлен уровень логирования из значения в конфиге.

Например с `Filters: {"child": "debug", "child/grandchild": "info"}`
Все события `grandchild.Debug` будут подавлены, в то время как события `child.Debug` не будут.

Если вы также создаете вложенный логер для "внуков", этот логер также унаследует уровень "внука".

### EventHook - перехват событий

В случае, если необходима какая-то обработка логера, есть пакет `logutil`.
Он предоставляет утилиту для добавления атрибутов в логи, не добавляя их в каждое событие.


Это делается путем создания EventHook:
```go
func SampleHook(ctx context.Context, stash logutil.Stash) logutil.Stash {
    val := ctx.Value(yourKey).(string)
    return logutil.WithAttr(stash, "key", val)
}
```

Hook можно зарегистрировать через `log.New`:
```go
logger, err := log.New(
    log.WithEventHook(SampleHook),
)
```

При использовании возвращаемого `logger` (или его детей), к каждому событию будет добавлена пара "key": "value".
Это может быть использовано для извлечения метаданных из контекста и внедрения их в события логера.